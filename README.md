警告：使用了大量embedding比对，由于个人洁癖，并且没有使用ANN索引。在热区记忆<5000时表现尚可，一旦超规模，延迟会线性甚至超线性恶化。


*原理：*
此处的权重并非统计学上的权重，而是根据访问频率而决定的热力。

总热力数值不变（默认1e7），在总热力值内划出一部分（如百分之10）作为热力池。
当有新记忆输入时，从热力池内提取热力并分给这段记忆，会首先尝试用一半的热力分给最接近的（近似度<0.75）记忆，根据满足条件的记忆数量（最多五个）平分热力，其余的则回收至热力池。该记忆则拥有剩下一半的热力
当热力池清空或者接近清空（无法安全进行下一次分配），则会将热区所有的记忆平均扣除一定的热力用于回收到热力池。当前高频访问的记忆排除在外。

语义簇是在内存里的，语义簇的热力决定了整个语义簇是否加载进内存。
热区是存储在内存里的。通过检测热区的语义簇的总热力规模对比热力总量的占比，如果超过某一比重（比如百分之20），则平均削减该语义簇下的每一条记忆的热力，回收进权重池。优先触发簇级削减，再全局回收，避免冲突。
设定单个记忆热力上限为总热力的 5%，如果超过，则削峰，回收进权重池。

当一条记忆的热力小于等于0,那么它将被转移至冷区。
冷区是储存在硬盘上的，即使冷区的记忆在统计学上热力<0,但是计算时依旧将整个冷区视作0

当某一记忆刚刚解冻时，系统需要从总的热力池内拨一部分（比如固定小整数，1000）作为启动资金，防止刚出现的记忆又跌回冷区。

记忆热力降至 0 时不立即移往硬盘，而是先进入“休眠态”。设定一个安全的内存维护界限，当这些休眠的记忆在热区占用的内存达到了512MB,则将这些记忆迁移至硬盘
分配近邻记忆时如果最有可能在冷区，则维护一个需要添加的列表，将这些记忆延迟更新进冷区。设定一个条目上限，当这些积攒的记忆达到了10条，则将这些记忆存入冷区
给近邻分配热力时，不要简单的平分，而是按照相似度的指数函数分配。越像，分到的越多，这样热力图的“峰值”会更清晰。

把所有热力值存储为整数（int32），总热力、热力池、新记忆初始热力等全部用整数单位。
分配时：先计算浮点比例（指数函数），然后用整数舍入（如floor）分配，确保总量精确守恒。
回收/扣除时：用整数除法或带余数处理（余数留在池中），避免碎片。
为了解决floor的系统性漏热力，我们需要进行一次累加，然后将累加与最大值进行比对，如果有差值，算到top-K高热力记忆里面

如果前3簇热力超过60%或前5簇超过75%，执行热力回收

*充斥着魔法数字对吧？那就对了！经济学就tmd全是魔法数字！语义相似度0.95+直接忽略谁规定的？我觉得那就是一句话所以不合并！*
